\section{Implementation}
\label{sec:implementation}
Our client is written in JavaScript and uses SoundManager, a
JavaScript audio player API \cite{soundmanager}. In contrast, our server code is
written in Python 2.7. Both use the Google App Engine API \cite{appengine}. In
Section~\ref{sec:channel}, Section~\ref{sec:storage} and Section~\ref{sec:considerations} 
we discuss how we utilize Google App Engine in our implementation.

\subsection{Client and Server Communication}
\label{sec:channel}
When the client wants to contact the server, it issues an HTTP
request, which is handled by the appropriate Python script handler.
Handlers in Google App Engine can only serve requests within a
time limit, which is why we chose to store session data within
the Datastore.

In contrast, when the server wants to contact a client, is uses 
the Channel service. Channels are persistent connections that 
allow updates to propagate to clients without the use of polling.
This is the mechanism with which we send updates to participants
of a session. A channel is created as follows: 
\begin{enumerate}
  \item The client contacts the server
  \item The server generates a channel ID and sends back a token
  \item The client connects to the channel using the token
\end{enumerate}
The client receives updates by listening on the channel by opening
a socket and does appropriate actions based on the message received.
Updates to the channel are made via HTTP requests from clients. When
a client disconnects from the channel, a message containing the 
corresponding channel ID is sent to the server, and appropriate
cleanup is performed.

\subsection{Datastore and Blobstore}
\label{sec:storage}
As mentioned before, Datastore and Blobstore are used to store a 
variety of information. Both Datastore and Blobstore have constant access time and are highly 
reliable means of storage. Google App Engine's Datastore uses the
High Replication Datastore built atop BigTable \cite{bigtable}. Writes
use the Paxos algorithm and changes are propagated to non-participating
replicas asynchronously. App Engine Datastore 
provides high read/write availability, atomic transactions, and
strong read consistency using get(). Queries, however, only 
guarantee eventual consistency. Thus, for our application, we use
get() to retrieve entries for time-sensitive operations, such as 
propagating control commands from the host, and queries for less 
urgent actions. \cite{appengine}\cite{datastore}

Blobstore is a datastore that holds large data objects (blobs) that 
are too big to be stored in the Datastore. Once a blob has been 
created, it cannot be modified; thus, it can be considered read-only
storage. We choose Blobstore to serve our content due to the higher
file size limit. Moreover, it also performs automatic caching on its 
data. \cite{appengine}

\subsection{Design Considerations}
\label{sec:considerations}
We made certain decisions in order to achieve the goals discussed
in Section~\ref{sec:intro}. In this section we summarize and discuss these choices.
\begin{enumerate}
  \item \textbf{Performance}: Songs are fetched by the client as soon as they are available, 
  		allowing for seemless transitions between songs.
  		We also perform synchronization, as discussed in Section~\ref{sec:sync}, 
  		and use eventually consistent queries when possible, as mentioned in 
  		Section~\ref{sec:storage}.
  \item \textbf{Availability}: We rely on Google services such as 
  		Datastore and Blobstore, which are highly replicated and reliable. 
  		In addition, HTTP requests to the server are served as long as 
  		Google App Engine is available. When a listener goes offline,
  		this does not affect session availability of the other listeners. 
  \item \textbf{Scalability}: For scalability purposes, we allow concurrent requests.
  		To minimize the number and size of messages, we allow incremental
  		updates. We do not send all session data on an update except when
  		a listener joins a session.
\end{enumerate}
